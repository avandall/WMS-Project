<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMS Service Layer - Deep Dive</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #d63384 0%, #e91e63 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.2em; opacity: 0.9; }
        .content { padding: 40px; }
        .section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .section h2 {
            color: #d63384;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #e91e63;
        }
        .diagram-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.8;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .code-example .comment { color: #6A9955; }
        .code-example .keyword { color: #C586C0; }
        .code-example .function { color: #DCDCAA; }
        .code-example .string { color: #CE9178; }
        .code-example .class { color: #4EC9B0; }
        .code-example .number { color: #B5CEA8; }
        .explanation {
            background: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            line-height: 1.8;
        }
        .explanation h3 {
            color: #1976D2;
            margin-bottom: 15px;
        }
        .file-path {
            background: #263238;
            color: #80CBC4;
            padding: 10px 15px;
            border-radius: 5px 5px 0 0;
            font-family: monospace;
            font-size: 13px;
            margin-bottom: -10px;
        }
        .pattern-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .pattern-box h4 {
            color: #F57C00;
            margin-bottom: 10px;
        }
        .key-concept {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }
        .key-concept h3 {
            margin-bottom: 10px;
            font-size: 1.5em;
        }
        ul.checklist {
            list-style: none;
            padding-left: 0;
        }
        ul.checklist li {
            padding: 8px 0 8px 30px;
            position: relative;
        }
        ul.checklist li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #4CAF50;
            font-weight: bold;
            font-size: 1.2em;
        }
        .collapsible {
            cursor: pointer;
            padding: 15px;
            background: #f093fb;
            color: white;
            border: none;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 1.1em;
            font-weight: bold;
            width: 100%;
            text-align: left;
            transition: background 0.3s;
        }
        .collapsible:hover {
            background: #d97de8;
        }
        .collapsible:after {
            content: '‚ñº';
            float: right;
            transition: transform 0.3s;
        }
        .collapsible.active:after {
            transform: rotate(180deg);
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .diagram-container:hover {
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            transition: box-shadow 0.3s;
        }
        .copy-btn {
            position: relative;
            float: right;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-top: -5px;
        }
        .copy-btn:hover {
            background: #45a049;
        }
        .copy-btn:active {
            background: #3d8b40;
        }
        code {
            background: #2d2d2d;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-content {
            background-color: #1e1e1e;
            margin: 3% auto;
            padding: 0;
            border-radius: 15px;
            width: 85%;
            max-width: 1200px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: slideDown 0.3s;
        }
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            background: linear-gradient(135deg, #d63384 0%, #e91e63 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            margin: 0;
            font-size: 1.8em;
        }
        .close {
            color: white;
            font-size: 35px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }
        .close:hover { color: #ff6b6b; }
        .modal-body {
            padding: 30px;
            color: #d4d4d4;
        }
        .modal-body pre {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #e91e63;
        }
        .modal-body h3 {
            color: #f093fb;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        .clickable-node {
            cursor: pointer;
            transition: filter 0.2s;
        }
        .clickable-node:hover {
            filter: brightness(1.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Service Layer Deep Dive</h1>
            <p>Business Logic Orchestration - Multi-Repository Coordination, Validation, Transactions</p>
        </div>
        
        <div class="content">
            <!-- SERVICE LAYER OVERVIEW -->
            <div class="section">
                <h2>üèõÔ∏è 1. Service Layer Architecture</h2>
                
                <div class="key-concept">
                    <h3>üéØ Purpose</h3>
                    <p>Service Layer coordinates multiple repositories and implements business logic. It enforces business rules, validates operations, and manages transactions spanning multiple entities.</p>
                </div>
                
                <div class="diagram-container">
                    <div class="mermaid">
                    graph TB
                        API[API Layer / Controllers] --> Service1[DocumentService]
                        API --> Service2[ProductService]
                        API --> Service3[WarehouseService]
                        
                        Service1 --> Repo1[DocumentRepo]
                        Service1 --> Repo2[WarehouseRepo]
                        Service1 --> Repo3[ProductRepo]
                        Service1 --> Repo4[InventoryRepo]
                        
                        Service2 --> Repo3
                        Service2 --> Repo4
                        
                        Service3 --> Repo2
                        Service3 --> Repo4
                        
                        Repo1 --> DB[(PostgreSQL)]
                        Repo2 --> DB
                        Repo3 --> DB
                        Repo4 --> DB
                        
                        Service1 --> TxManager[Transaction Manager]
                        TxManager --> Session[SQLAlchemy Session]
                        Session --> DB
                        
                        style Service1 fill:#FF9800,stroke:#E65100,stroke-width:3px,color:#fff
                        style API fill:#2196F3,stroke:#1976D2,stroke-width:2px,color:#fff
                        style TxManager fill:#E91E63,stroke:#880E4F,stroke-width:2px,color:#fff
                    </div>
                </div>

                <div class="explanation">
                    <h3>üí° Why Services?</h3>
                    <p><strong>1. Business Logic Location:</strong> Services are where business rules live. Repositories only do CRUD, services orchestrate complex workflows.</p>
                    <p><strong>2. Transaction Boundaries:</strong> Services manage transaction scope across multiple repositories.</p>
                    <p><strong>3. Validation:</strong> Services validate inputs and business rules before touching the database.</p>
                    <p><strong>4. Reusability:</strong> Multiple API endpoints can reuse the same service methods.</p>
                </div>
            </div>

            <!-- DOCUMENT SERVICE STRUCTURE -->
            <div class="section">
                <h2>üìÑ 2. DocumentService Architecture</h2>
                
                <div class="file-path">üìÅ app/services/document_service.py</div>
                <div class="code-example"><span class="keyword">class</span> <span class="class">DocumentService</span>:
    <span class="string">"""
    Orchestrates document lifecycle across multiple repositories.
    
    Manages:
    - Document creation (IMPORT/EXPORT/TRANSFER)
    - Document posting (inventory movements)
    - Document cancellation
    - Multi-repository transactions
    """</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(
        <span class="keyword">self</span>,
        document_repo: <span class="class">IDocumentRepo</span>,
        warehouse_repo: <span class="class">IWarehouseRepo</span>,
        product_repo: <span class="class">IProductRepo</span>,
        inventory_repo: <span class="class">IInventoryRepo</span>,
        session: <span class="class">Optional</span>[<span class="class">Session</span>] = <span class="class">None</span>,
    ):
        <span class="comment"># Repository dependencies (injected)</span>
        <span class="keyword">self</span>.document_repo = document_repo
        <span class="keyword">self</span>.warehouse_repo = warehouse_repo
        <span class="keyword">self</span>.product_repo = product_repo
        <span class="keyword">self</span>.inventory_repo = inventory_repo
        
        <span class="comment"># Session for transaction management</span>
        <span class="keyword">self</span>.session = session
        
        <span class="comment"># ID generator for new documents</span>
        <span class="keyword">self</span>._doc_id_generator = <span class="class">IDGenerator</span>.<span class="function">get_generator</span>(<span class="string">"document"</span>)</div>

                <div class="explanation">
                    <h3>üí° Dependency Injection Pattern</h3>
                    <p>Services receive repositories through constructor injection. This makes services:</p>
                    <ul class="checklist">
                        <li><strong>Testable:</strong> Inject mock repositories in unit tests</li>
                        <li><strong>Flexible:</strong> Swap implementations without changing service code</li>
                        <li><strong>Clear:</strong> Dependencies are explicit in constructor</li>
                    </ul>
                </div>
            </div>

            <!-- CREATE DOCUMENT OPERATIONS -->
            <div class="section">
                <h2>üìù 3. Create Operations: Multi-Repository Validation</h2>
                
                <div class="diagram-container">
                    <div class="mermaid">
                    sequenceDiagram
                        participant API
                        participant Service as DocumentService
                        participant WHRepo as WarehouseRepo
                        participant ProdRepo as ProductRepo
                        participant DocRepo as DocumentRepo
                        
                        API->>Service: create_import_document(warehouse_id, items)
                        
                        Service->>WHRepo: get(warehouse_id)
                        WHRepo-->>Service: Warehouse or None
                        
                        alt Warehouse Not Found
                            Service-->>API: ‚ùå WarehouseNotFoundError
                        end
                        
                        loop For each item
                            Service->>ProdRepo: get(product_id)
                            ProdRepo-->>Service: Product or None
                            
                            alt Product Not Found
                                Service-->>API: ‚ùå ProductNotFoundError
                            end
                            
                            Service->>Service: Validate quantity > 0
                            Service->>Service: Create DocumentProduct
                        end
                        
                        Service->>Service: Generate document_id
                        Service->>Service: Create Document (DRAFT status)
                        
                        Service->>DocRepo: save(document)
                        DocRepo-->>Service: Success ‚úì
                        
                        Service-->>API: ‚úÖ Document (DRAFT)
                    </div>
                </div>

                <div class="file-path">üìÅ app/services/document_service.py</div>
                <div class="code-example"><span class="keyword">def</span> <span class="function">create_import_document</span>(
    <span class="keyword">self</span>,
    to_warehouse_id: <span class="class">int</span>,
    items: <span class="class">List</span>[<span class="class">Dict</span>[<span class="class">str</span>, <span class="class">Any</span>]],
    created_by: <span class="class">str</span>,
    note: <span class="class">Optional</span>[<span class="class">str</span>] = <span class="class">None</span>,
) -> <span class="class">Document</span>:
    <span class="string">"""
    Create import document with validation.
    
    Steps:
    1. Validate warehouse exists
    2. Validate all products exist
    3. Convert items to domain objects
    4. Create document in DRAFT status
    
    Args:
        to_warehouse_id: Destination warehouse
        items: [{"product_id": 1, "quantity": 10, "unit_price": 99.99}, ...]
        created_by: Username creating document
        note: Optional note
        
    Returns:
        Document in DRAFT status
    """</span>
    <span class="comment"># Step 1: Validate warehouse exists</span>
    warehouse = <span class="keyword">self</span>.warehouse_repo.<span class="function">get</span>(to_warehouse_id)
    <span class="keyword">if not</span> warehouse:
        logger.<span class="function">error</span>(<span class="string">f"Warehouse {to_warehouse_id} not found"</span>)
        <span class="keyword">raise</span> <span class="class">WarehouseNotFoundError</span>(<span class="string">f"Warehouse {to_warehouse_id} not found"</span>)
    
    <span class="comment"># Step 2: Validate and convert items</span>
    document_items = <span class="keyword">self</span>.<span class="function">_validate_and_convert_items</span>(items, check_product_exists=<span class="class">True</span>)
    
    <span class="comment"># Step 3: Generate document ID</span>
    document_id = <span class="keyword">self</span>.<span class="function">_doc_id_generator</span>()
    
    <span class="comment"># Step 4: Create document entity</span>
    document = <span class="class">Document</span>(
        document_id=document_id,
        doc_type=<span class="class">DocumentType</span>.IMPORT,
        to_warehouse_id=to_warehouse_id,
        items=document_items,
        created_by=created_by,
        note=note,
        status=<span class="class">DocumentStatus</span>.DRAFT,  <span class="comment"># Always DRAFT on creation</span>
    )
    
    <span class="comment"># Step 5: Persist to database</span>
    <span class="keyword">self</span>.document_repo.<span class="function">save</span>(document)
    logger.<span class="function">info</span>(<span class="string">f"‚úÖ Created import document {document_id}"</span>)
    <span class="keyword">return</span> document

<span class="keyword">def</span> <span class="function">_validate_and_convert_items</span>(
    <span class="keyword">self</span>,
    items: <span class="class">List</span>[<span class="class">Dict</span>[<span class="class">str</span>, <span class="class">Any</span>]],
    check_product_exists: <span class="class">bool</span> = <span class="class">True</span>,
) -> <span class="class">List</span>[<span class="class">DocumentProduct</span>]:
    <span class="string">"""Convert dict items to domain objects with validation"""</span>
    document_items = []
    
    <span class="keyword">for</span> item <span class="keyword">in</span> items:
        product_id = item[<span class="string">"product_id"</span>]
        quantity = item[<span class="string">"quantity"</span>]
        unit_price = item.<span class="function">get</span>(<span class="string">"unit_price"</span>, <span class="number">0.0</span>)
        
        <span class="comment"># Validate quantity</span>
        <span class="keyword">if</span> quantity <= <span class="number">0</span>:
            <span class="keyword">raise</span> <span class="class">ValidationError</span>(<span class="string">f"Quantity must be > 0, got {quantity}"</span>)
        
        <span class="comment"># Validate product exists</span>
        <span class="keyword">if</span> check_product_exists:
            product = <span class="keyword">self</span>.product_repo.<span class="function">get</span>(product_id)
            <span class="keyword">if not</span> product:
                <span class="keyword">raise</span> <span class="class">ProductNotFoundError</span>(<span class="string">f"Product {product_id} not found"</span>)
        
        <span class="comment"># Create domain object</span>
        document_items.<span class="function">append</span>(
            <span class="class">DocumentProduct</span>(
                product_id=product_id,
                quantity=quantity,
                unit_price=unit_price,
            )
        )
    
    <span class="keyword">return</span> document_items</div>

                <div class="pattern-box">
                    <h4>üèóÔ∏è Why Validate in Service Layer?</h4>
                    <p><strong>Repositories can't validate across entities:</strong> Repository only knows about its own entity. It can't check if a referenced warehouse exists.</p>
                    <p><strong>Services see the big picture:</strong> Services coordinate multiple repositories and enforce business rules that span multiple entities.</p>
                </div>
            </div>

            <!-- POST DOCUMENT TRANSACTION -->
            <div class="section">
                <h2>üîê 4. Post Document: ACID Transaction Management</h2>
                
                <div class="diagram-container">
                    <div class="mermaid">
                    sequenceDiagram
                        participant API
                        participant Service as DocumentService
                        participant Repos as 4 Repositories
                        participant Session
                        participant DB as PostgreSQL
                        
                        API->>Service: post_document(document_id, approved_by)
                        
                        Service->>Service: _get_document_for_processing()
                        Service->>Service: Validate status == DRAFT
                        
                        Service->>Repos: set_auto_commit(False)
                        Note over Repos: Disable auto-commit<br/>on all repositories
                        
                        Service->>Session: BEGIN TRANSACTION
                        
                        alt IMPORT Document
                            Service->>Service: _execute_import_operations()
                            loop For each item
                                Service->>Repos: inventory_repo.add_quantity()
                                Note over Session: Queued (not committed)
                            end
                        else EXPORT Document
                            Service->>Service: _execute_export_operations()
                            loop For each item
                                Service->>Repos: Check stock exists
                                Service->>Repos: inventory_repo.remove_quantity()
                                Note over Session: Queued (not committed)
                            end
                        else TRANSFER Document
                            Service->>Service: _execute_transfer_operations()
                            loop For each item
                                Service->>Repos: Remove from source
                                Service->>Repos: Add to destination
                                Note over Session: Queued (not committed)
                            end
                        end
                        
                        Service->>Repos: document.status = POSTED
                        Service->>Repos: document_repo.save(document)
                        Note over Session: Queued (not committed)
                        
                        alt All Operations Success
                            Service->>Session: commit()
                            Session->>DB: COMMIT
                            DB-->>Session: ‚úÖ Success
                            Service-->>API: ‚úÖ Posted Document
                        else Any Operation Fails
                            Service->>Session: rollback()
                            Session->>DB: ROLLBACK
                            DB-->>Session: ‚úÖ Rolled back
                            Service-->>API: ‚ùå Exception
                        end
                        
                        Service->>Repos: set_auto_commit(True)
                        Note over Repos: Restore auto-commit
                    </div>
                </div>

                <div class="file-path">üìÅ app/services/document_service.py</div>
                <div class="code-example"><span class="keyword">def</span> <span class="function">post_document</span>(<span class="keyword">self</span>, document_id: <span class="class">int</span>, approved_by: <span class="class">str</span>) -> <span class="class">Document</span>:
    <span class="string">"""
    Post document with ACID transaction.
    
    All operations are atomic:
    - Either ALL inventory movements succeed
    - Or ALL are rolled back (no partial state)
    
    This prevents inventory corruption in production.
    """</span>
    logger.<span class="function">info</span>(<span class="string">f"üöÄ Posting document {document_id}"</span>)
    
    <span class="comment"># Step 1: Load and validate document</span>
    document = <span class="keyword">self</span>.<span class="function">_get_document_for_processing</span>(document_id)
    
    <span class="keyword">if not</span> <span class="keyword">self</span>.session:
        logger.<span class="function">warning</span>(<span class="string">"‚ö†Ô∏è No session - using legacy mode"</span>)
        <span class="keyword">return self</span>.<span class="function">_post_document_legacy</span>(document, approved_by)
    
    <span class="keyword">try</span>:
        <span class="comment"># Step 2: Disable auto-commit for transaction control</span>
        <span class="keyword">self</span>.<span class="function">_set_repos_auto_commit</span>(<span class="class">False</span>)
        logger.<span class="function">debug</span>(<span class="string">"üîí Transaction started"</span>)
        
        <span class="comment"># Step 3: Execute inventory operations (queued, not committed)</span>
        <span class="keyword">if</span> document.doc_type == <span class="class">DocumentType</span>.IMPORT:
            <span class="keyword">self</span>.<span class="function">_execute_import_operations</span>(document)
        <span class="keyword">elif</span> document.doc_type == <span class="class">DocumentType</span>.EXPORT:
            <span class="keyword">self</span>.<span class="function">_execute_export_operations</span>(document)
        <span class="keyword">elif</span> document.doc_type == <span class="class">DocumentType</span>.TRANSFER:
            <span class="keyword">self</span>.<span class="function">_execute_transfer_operations</span>(document)
        
        <span class="comment"># Step 4: Update document status (queued)</span>
        document.status = <span class="class">DocumentStatus</span>.POSTED
        document.approved_by = approved_by
        document.posted_at = <span class="function">datetime.now</span>()
        <span class="keyword">self</span>.document_repo.<span class="function">save</span>(document)
        
        <span class="comment"># Step 5: COMMIT all changes atomically</span>
        <span class="keyword">self</span>.session.<span class="function">commit</span>()
        logger.<span class="function">info</span>(<span class="string">f"‚úÖ Document {document_id} posted successfully"</span>)
        <span class="keyword">return</span> document
        
    <span class="keyword">except</span> <span class="class">InsufficientStockError</span> <span class="keyword">as</span> e:
        <span class="comment"># Business rule violation - rollback</span>
        <span class="keyword">self</span>.session.<span class="function">rollback</span>()
        logger.<span class="function">error</span>(<span class="string">f"‚ùå Insufficient stock: {e}"</span>)
        <span class="keyword">raise</span>
        
    <span class="keyword">except</span> <span class="class">Exception</span> <span class="keyword">as</span> e:
        <span class="comment"># ANY error - rollback everything</span>
        <span class="keyword">self</span>.session.<span class="function">rollback</span>()
        logger.<span class="function">error</span>(<span class="string">f"‚ùå Transaction failed: {type(e).__name__}: {e}"</span>)
        <span class="keyword">raise</span> <span class="class">ValidationError</span>(<span class="string">f"Failed to post: {e}"</span>)
        
    <span class="keyword">finally</span>:
        <span class="comment"># Step 6: Always restore auto-commit</span>
        <span class="keyword">self</span>.<span class="function">_set_repos_auto_commit</span>(<span class="class">True</span>)
        logger.<span class="function">debug</span>(<span class="string">"üîì Transaction closed"</span>)</div>

                <div class="explanation">
                    <h3>üí° Why ACID Matters</h3>
                    <p><strong>Without Transactions (Dangerous):</strong></p>
                    <div class="code-example"><span class="comment"># ‚ùå WRONG: Each operation commits immediately</span>
inventory_repo.<span class="function">add_quantity</span>(product_id=<span class="number">1</span>, qty=<span class="number">10</span>)  <span class="comment"># COMMIT 1</span>
inventory_repo.<span class="function">add_quantity</span>(product_id=<span class="number">2</span>, qty=<span class="number">20</span>)  <span class="comment"># COMMIT 2</span>
inventory_repo.<span class="function">add_quantity</span>(product_id=<span class="number">3</span>, qty=<span class="number">30</span>)  <span class="comment"># üí• EXCEPTION!</span>

<span class="comment"># Result: Products 1 and 2 are in database (corrupted state!)
# Product 3 failed but first 2 committed</span></div>

                    <p style="margin-top: 20px;"><strong>With Transactions (Correct):</strong></p>
                    <div class="code-example"><span class="comment"># ‚úÖ CORRECT: All operations queued until commit</span>
<span class="keyword">try</span>:
    inventory_repo.<span class="function">add_quantity</span>(product_id=<span class="number">1</span>, qty=<span class="number">10</span>)  <span class="comment"># Queued</span>
    inventory_repo.<span class="function">add_quantity</span>(product_id=<span class="number">2</span>, qty=<span class="number">20</span>)  <span class="comment"># Queued</span>
    inventory_repo.<span class="function">add_quantity</span>(product_id=<span class="number">3</span>, qty=<span class="number">30</span>)  <span class="comment"># üí• EXCEPTION!</span>
    session.<span class="function">commit</span>()  <span class="comment"># Never reached</span>
<span class="keyword">except</span>:
    session.<span class="function">rollback</span>()  <span class="comment"># Discards ALL changes</span>

<span class="comment"># Result: Database unchanged (consistent state!)
# All or nothing - ACID guarantee</span></div>
                </div>

                <div class="pattern-box">
                    <h4>üèóÔ∏è Transaction Control Pattern</h4>
                    <div class="code-example"><span class="keyword">def</span> <span class="function">_set_repos_auto_commit</span>(<span class="keyword">self</span>, enabled: <span class="class">bool</span>) -> <span class="class">None</span>:
    <span class="string">"""Control auto-commit on all repositories"""</span>
    <span class="keyword">for</span> repo <span class="keyword">in</span> [
        <span class="keyword">self</span>.warehouse_repo,
        <span class="keyword">self</span>.inventory_repo,
        <span class="keyword">self</span>.document_repo,
        <span class="keyword">self</span>.product_repo,
    ]:
        <span class="keyword">if</span> <span class="function">hasattr</span>(repo, <span class="string">'set_auto_commit'</span>):
            repo.<span class="function">set_auto_commit</span>(enabled)

<span class="comment"># Usage:
# 1. Disable auto-commit before multi-step operation
# 2. Execute all operations (queued in session)
# 3. Manually commit() or rollback()
# 4. Always restore auto-commit in finally block</span></div>
                </div>
            </div>

            <!-- INVENTORY OPERATIONS -->
            <div class="section">
                <h2>üì¶ 5. Inventory Operations: Business Rules</h2>
                
                <div class="file-path">üìÅ app/services/document_service.py</div>
                <div class="code-example"><span class="keyword">def</span> <span class="function">_execute_import_operations</span>(<span class="keyword">self</span>, document: <span class="class">Document</span>) -> <span class="class">None</span>:
    <span class="string">"""Add inventory for each item (IMPORT logic)"""</span>
    warehouse_id = document.to_warehouse_id
    
    <span class="keyword">for</span> item <span class="keyword">in</span> document.items:
        logger.<span class="function">debug</span>(<span class="string">f"‚ûï Adding {item.quantity} of product {item.product_id}"</span>)
        
        <span class="comment"># Add quantity to warehouse inventory</span>
        <span class="keyword">self</span>.warehouse_repo.<span class="function">add_product_to_warehouse</span>(
            warehouse_id=warehouse_id,
            product_id=item.product_id,
            quantity=item.quantity,
        )

<span class="keyword">def</span> <span class="function">_execute_export_operations</span>(<span class="keyword">self</span>, document: <span class="class">Document</span>) -> <span class="class">None</span>:
    <span class="string">"""Remove inventory with stock validation (EXPORT logic)"""</span>
    warehouse_id = document.from_warehouse_id
    
    <span class="keyword">for</span> item <span class="keyword">in</span> document.items:
        <span class="comment"># Check stock exists before removal</span>
        inventory_item = <span class="keyword">self</span>.inventory_repo.<span class="function">get</span>(
            warehouse_id=warehouse_id,
            product_id=item.product_id,
        )
        
        <span class="keyword">if not</span> inventory_item <span class="keyword">or</span> inventory_item.quantity < item.quantity:
            current_qty = inventory_item.quantity <span class="keyword">if</span> inventory_item <span class="keyword">else</span> <span class="number">0</span>
            <span class="keyword">raise</span> <span class="class">InsufficientStockError</span>(
                <span class="string">f"Product {item.product_id}: need {item.quantity}, "</span>
                <span class="string">f"have {current_qty}"</span>
            )
        
        logger.<span class="function">debug</span>(<span class="string">f"‚ûñ Removing {item.quantity} of product {item.product_id}"</span>)
        
        <span class="comment"># Remove quantity from warehouse</span>
        <span class="keyword">self</span>.warehouse_repo.<span class="function">remove_product_from_warehouse</span>(
            warehouse_id=warehouse_id,
            product_id=item.product_id,
            quantity=item.quantity,
        )

<span class="keyword">def</span> <span class="function">_execute_transfer_operations</span>(<span class="keyword">self</span>, document: <span class="class">Document</span>) -> <span class="class">None</span>:
    <span class="string">"""Move inventory between warehouses (TRANSFER logic)"""</span>
    from_warehouse_id = document.from_warehouse_id
    to_warehouse_id = document.to_warehouse_id
    
    <span class="keyword">for</span> item <span class="keyword">in</span> document.items:
        <span class="comment"># Validate stock in source warehouse</span>
        inventory_item = <span class="keyword">self</span>.inventory_repo.<span class="function">get</span>(
            warehouse_id=from_warehouse_id,
            product_id=item.product_id,
        )
        
        <span class="keyword">if not</span> inventory_item <span class="keyword">or</span> inventory_item.quantity < item.quantity:
            current_qty = inventory_item.quantity <span class="keyword">if</span> inventory_item <span class="keyword">else</span> <span class="number">0</span>
            <span class="keyword">raise</span> <span class="class">InsufficientStockError</span>(
                <span class="string">f"Source warehouse {from_warehouse_id}: "</span>
                <span class="string">f"need {item.quantity}, have {current_qty}"</span>
            )
        
        logger.<span class="function">debug</span>(
            <span class="string">f"üîÑ Transferring {item.quantity} of product {item.product_id} "</span>
            <span class="string">f"from WH{from_warehouse_id} to WH{to_warehouse_id}"</span>
        )
        
        <span class="comment"># Remove from source</span>
        <span class="keyword">self</span>.warehouse_repo.<span class="function">remove_product_from_warehouse</span>(
            warehouse_id=from_warehouse_id,
            product_id=item.product_id,
            quantity=item.quantity,
        )
        
        <span class="comment"># Add to destination</span>
        <span class="keyword">self</span>.warehouse_repo.<span class="function">add_product_to_warehouse</span>(
            warehouse_id=to_warehouse_id,
            product_id=item.product_id,
            quantity=item.quantity,
        )</div>

                <div class="explanation">
                    <h3>üí° Business Rules Enforcement</h3>
                    <ul class="checklist">
                        <li><strong>Import:</strong> Always succeeds (adding stock can't fail)</li>
                        <li><strong>Export:</strong> Must validate stock exists before removal</li>
                        <li><strong>Transfer:</strong> Must validate source stock + add to destination</li>
                        <li><strong>All operations:</strong> Logged for audit trail</li>
                    </ul>
                </div>
            </div>

            <!-- TESTING SERVICES -->
            <div class="section">
                <h2>‚úÖ 6. Testing Service Layer</h2>
                
                <div class="file-path">üìÅ tests/test_document_service.py</div>
                <div class="code-example"><span class="keyword">import</span> pytest
<span class="keyword">from</span> unittest.mock <span class="keyword">import</span> <span class="class">Mock</span>, <span class="class">MagicMock</span>

<span class="keyword">@pytest</span>.<span class="function">fixture</span>
<span class="keyword">def</span> <span class="function">mock_repos</span>():
    <span class="string">"""Create mock repositories for testing"""</span>
    <span class="keyword">return</span> {
        <span class="string">'document'</span>: <span class="class">Mock</span>(spec=<span class="class">IDocumentRepo</span>),
        <span class="string">'warehouse'</span>: <span class="class">Mock</span>(spec=<span class="class">IWarehouseRepo</span>),
        <span class="string">'product'</span>: <span class="class">Mock</span>(spec=<span class="class">IProductRepo</span>),
        <span class="string">'inventory'</span>: <span class="class">Mock</span>(spec=<span class="class">IInventoryRepo</span>),
    }

<span class="keyword">def</span> <span class="function">test_create_import_validates_warehouse</span>(mock_repos):
    <span class="comment"># Arrange: Warehouse doesn't exist</span>
    mock_repos[<span class="string">'warehouse'</span>].get.<span class="function">return_value</span> = <span class="class">None</span>
    
    service = <span class="class">DocumentService</span>(**mock_repos)
    
    <span class="comment"># Act & Assert: Should raise error</span>
    <span class="keyword">with</span> pytest.<span class="function">raises</span>(<span class="class">WarehouseNotFoundError</span>):
        service.<span class="function">create_import_document</span>(
            to_warehouse_id=<span class="number">999</span>,
            items=[{<span class="string">"product_id"</span>: <span class="number">1</span>, <span class="string">"quantity"</span>: <span class="number">10</span>}],
            created_by=<span class="string">"user1"</span>,
        )

<span class="keyword">def</span> <span class="function">test_post_document_commits_on_success</span>(mock_repos):
    <span class="comment"># Arrange: Mock successful operation</span>
    mock_session = <span class="class">Mock</span>(spec=<span class="class">Session</span>)
    document = <span class="class">Document</span>(
        document_id=<span class="number">1</span>,
        doc_type=<span class="class">DocumentType</span>.IMPORT,
        status=<span class="class">DocumentStatus</span>.DRAFT,
        items=[],
    )
    mock_repos[<span class="string">'document'</span>].get.<span class="function">return_value</span> = document
    
    service = <span class="class">DocumentService</span>(**mock_repos, session=mock_session)
    
    <span class="comment"># Act</span>
    result = service.<span class="function">post_document</span>(<span class="number">1</span>, <span class="string">"approver1"</span>)
    
    <span class="comment"># Assert</span>
    <span class="keyword">assert</span> result.status == <span class="class">DocumentStatus</span>.POSTED
    mock_session.commit.<span class="function">assert_called_once</span>()  <span class="comment"># Verify commit</span>
    mock_session.rollback.<span class="function">assert_not_called</span>()  <span class="comment"># No rollback</span>

<span class="keyword">def</span> <span class="function">test_post_document_rolls_back_on_error</span>(mock_repos):
    <span class="comment"># Arrange: Mock operation that raises exception</span>
    mock_session = <span class="class">Mock</span>(spec=<span class="class">Session</span>)
    mock_repos[<span class="string">'warehouse'</span>].add_product_to_warehouse.<span class="function">side_effect</span> = \
        <span class="class">Exception</span>(<span class="string">"Database error"</span>)
    
    document = <span class="class">Document</span>(
        document_id=<span class="number">1</span>,
        doc_type=<span class="class">DocumentType</span>.IMPORT,
        status=<span class="class">DocumentStatus</span>.DRAFT,
        items=[<span class="class">DocumentProduct</span>(product_id=<span class="number">1</span>, quantity=<span class="number">10</span>)],
    )
    mock_repos[<span class="string">'document'</span>].get.<span class="function">return_value</span> = document
    
    service = <span class="class">DocumentService</span>(**mock_repos, session=mock_session)
    
    <span class="comment"># Act & Assert</span>
    <span class="keyword">with</span> pytest.<span class="function">raises</span>(<span class="class">ValidationError</span>):
        service.<span class="function">post_document</span>(<span class="number">1</span>, <span class="string">"approver1"</span>)
    
    <span class="comment"># Verify rollback was called</span>
    mock_session.rollback.<span class="function">assert_called_once</span>()
    mock_session.commit.<span class="function">assert_not_called</span>()</div>

                <div class="explanation">
                    <h3>üí° Testing Strategy</h3>
                    <ul class="checklist">
                        <li><strong>Use mocks:</strong> Don't hit database in unit tests</li>
                        <li><strong>Test happy path:</strong> Verify successful operations</li>
                        <li><strong>Test error paths:</strong> Verify rollback on failure</li>
                        <li><strong>Test validation:</strong> Verify business rules enforced</li>
                        <li><strong>Integration tests:</strong> Use real repositories with test database</li>
                    </ul>
                </div>
            </div>

            <div class="key-concept" style="margin-top: 50px;">
                <h3>üìö How to Apply Service Layer in Your Projects</h3>
                <ul class="checklist">
                    <li><strong>Single Responsibility:</strong> Each service handles one domain area (documents, orders, users)</li>
                    <li><strong>Coordinate Repositories:</strong> Services orchestrate multiple repositories</li>
                    <li><strong>Enforce Business Rules:</strong> Validate before database operations</li>
                    <li><strong>Manage Transactions:</strong> Control commit/rollback boundaries</li>
                    <li><strong>Keep Services Thin:</strong> Delegate data access to repositories</li>
                    <li><strong>Use Dependency Injection:</strong> Pass dependencies in constructor</li>
                    <li><strong>Test with Mocks:</strong> Fast unit tests without database</li>
                    <li><strong>Log Operations:</strong> Audit trail for debugging</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Modal for clickable diagrams -->
    <div id="codeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Code Details</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Content loaded dynamically -->
            </div>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true, 
            theme: 'default',
            flowchart: { useMaxWidth: true },
            sequence: { useMaxWidth: true }
        });
        
        // Code snippets for clickable service nodes
        const codeDetails = {
            'Service': {
                title: 'üéØ Service Layer Purpose',
                content: `
                    <h3>üí° What is a Service?</h3>
                    <p><strong>Orchestrator:</strong> Coordinates multiple repositories</p>
                    <p><strong>Business Logic:</strong> Enforces domain rules and validation</p>
                    <p><strong>Transaction Boundary:</strong> Manages commit/rollback scope</p>
                    <h3>üìÅ File: app/services/document_service.py</h3>
                    <pre>class DocumentService:
    def __init__(
        self,
        document_repo: IDocumentRepo,
        warehouse_repo: IWarehouseRepo,
        product_repo: IProductRepo,
        inventory_repo: IInventoryRepo,
        session: Optional[Session] = None
    ):
        self.document_repo = document_repo
        self.warehouse_repo = warehouse_repo
        self.product_repo = product_repo
        self.inventory_repo = inventory_repo
        self.session = session</pre>
                    <h3>üéØ Key Responsibilities</h3>
                    <p><strong>1. Validation:</strong> Check warehouse exists, products exist, stock sufficient</p>
                    <p><strong>2. Orchestration:</strong> Call multiple repositories in correct order</p>
                    <p><strong>3. Transactions:</strong> Ensure all-or-nothing execution</p>
                    <p><strong>4. Business Rules:</strong> Implement import/export/transfer logic</p>
                `
            },
            'Repos': {
                title: 'üì¶ Repository Dependencies',
                content: `
                    <h3>üí° Why Multiple Repositories?</h3>
                    <p>Service needs data from multiple entities:</p>
                    <pre>DocumentService uses:
- document_repo   ‚Üí CRUD for documents
- warehouse_repo  ‚Üí Validate warehouse exists
- product_repo    ‚Üí Validate products exist  
- inventory_repo  ‚Üí Add/remove inventory</pre>
                    <h3>üéØ Dependency Injection Pattern</h3>
                    <pre>service = DocumentService(
    document_repo=DocumentRepo(session),
    warehouse_repo=WarehouseRepo(session),
    product_repo=ProductRepo(session),
    inventory_repo=InventoryRepo(session),
    session=session
)</pre>
                    <h3>‚úÖ Benefits</h3>
                    <p><strong>Testability:</strong> Inject mock repos in tests</p>
                    <p><strong>Flexibility:</strong> Swap implementations</p>
                    <p><strong>Explicit:</strong> Dependencies visible in constructor</p>
                `
            },
            'TxManager': {
                title: 'üîê Transaction Manager',
                content: `
                    <h3>üìÅ File: app/services/document_service.py</h3>
                    <pre>def post_document(self, document_id, approved_by):
    try:
        # Step 1: Disable auto-commit
        self._set_repos_auto_commit(False)
        
        # Step 2: Execute operations (queued)
        self._execute_import_operations(document)
        document.status = DocumentStatus.POSTED
        self.document_repo.save(document)
        
        # Step 3: COMMIT all changes
        self.session.commit()
        
    except Exception as e:
        # Step 4: ROLLBACK on error
        self.session.rollback()
        raise
        
    finally:
        # Step 5: Restore auto-commit
        self._set_repos_auto_commit(True)</pre>
                    <h3>üí° ACID Guarantee</h3>
                    <p><strong>Atomic:</strong> All operations succeed or all fail</p>
                    <p><strong>Consistent:</strong> Database never in partial state</p>
                    <p><strong>Isolated:</strong> Other transactions don't see partial changes</p>
                    <p><strong>Durable:</strong> Committed data survives crashes</p>
                `
            },
            'Validation': {
                title: '‚úÖ Business Validation',
                content: `
                    <h3>üìÅ File: app/services/document_service.py</h3>
                    <pre>def create_import_document(self, to_warehouse_id, items, ...):
    # Validate warehouse exists
    warehouse = self.warehouse_repo.get(to_warehouse_id)
    if not warehouse:
        raise WarehouseNotFoundError(...)
    
    # Validate all products exist
    for item in items:
        product = self.product_repo.get(item['product_id'])
        if not product:
            raise ProductNotFoundError(...)
        
        # Validate quantity > 0
        if item['quantity'] <= 0:
            raise ValidationError("Quantity must be positive")
    
    # All valid ‚Üí Create document
    document = Document(...)
    self.document_repo.save(document)</pre>
                    <h3>üí° Why Validate in Service?</h3>
                    <p><strong>Repository can't:</strong> Only knows about its own entity</p>
                    <p><strong>Service can:</strong> Coordinates multiple repositories</p>
                    <p><strong>Fail fast:</strong> Catch errors before touching database</p>
                `
            },
            'ImportOps': {
                title: 'üì• Import Operations',
                content: `
                    <h3>üìÅ File: app/services/document_service.py</h3>
                    <pre>def _execute_import_operations(self, document):
    warehouse_id = document.to_warehouse_id
    
    for item in document.items:
        # Add quantity to warehouse inventory
        self.warehouse_repo.add_product_to_warehouse(
            warehouse_id=warehouse_id,
            product_id=item.product_id,
            quantity=item.quantity
        )</pre>
                    <h3>üí° Import Logic</h3>
                    <p><strong>Simple:</strong> Just add inventory - can't fail!</p>
                    <p><strong>No validation needed:</strong> Adding stock is always valid</p>
                    <p><strong>Logged:</strong> Every operation logged for audit trail</p>
                    <h3>üéØ Example</h3>
                    <pre>Document: Import 100 Laptops ‚Üí Warehouse A
Result: Warehouse A inventory += 100</pre>
                `
            },
            'ExportOps': {
                title: 'üì§ Export Operations',
                content: `
                    <h3>üìÅ File: app/services/document_service.py</h3>
                    <pre>def _execute_export_operations(self, document):
    warehouse_id = document.from_warehouse_id
    
    for item in document.items:
        # CHECK STOCK EXISTS
        inventory = self.inventory_repo.get(warehouse_id, item.product_id)
        if not inventory or inventory.quantity < item.quantity:
            current = inventory.quantity if inventory else 0
            raise InsufficientStockError(
                f"Need {item.quantity}, have {current}"
            )
        
        # Remove quantity from warehouse
        self.warehouse_repo.remove_product_from_warehouse(
            warehouse_id=warehouse_id,
            product_id=item.product_id,
            quantity=item.quantity
        )</pre>
                    <h3>üí° Export Logic</h3>
                    <p><strong>MUST validate stock:</strong> Can't remove what doesn't exist</p>
                    <p><strong>Fail fast:</strong> Check ALL items before removing ANY</p>
                    <p><strong>Atomic:</strong> All removals succeed or all rolled back</p>
                `
            },
            'TransferOps': {
                title: 'üîÑ Transfer Operations',
                content: `
                    <h3>üìÅ File: app/services/document_service.py</h3>
                    <pre>def _execute_transfer_operations(self, document):
    from_wh = document.from_warehouse_id
    to_wh = document.to_warehouse_id
    
    for item in document.items:
        # Validate stock in source
        inventory = self.inventory_repo.get(from_wh, item.product_id)
        if not inventory or inventory.quantity < item.quantity:
            raise InsufficientStockError(...)
        
        # Remove from source
        self.warehouse_repo.remove_product_from_warehouse(
            warehouse_id=from_wh,
            product_id=item.product_id,
            quantity=item.quantity
        )
        
        # Add to destination
        self.warehouse_repo.add_product_to_warehouse(
            warehouse_id=to_wh,
            product_id=item.product_id,
            quantity=item.quantity
        )</pre>
                    <h3>üí° Transfer Logic</h3>
                    <p><strong>Two-phase:</strong> Remove from source, add to destination</p>
                    <p><strong>MUST be atomic:</strong> If add fails, remove must rollback</p>
                    <p><strong>Validation first:</strong> Check all items before moving ANY</p>
                `
            },
            'Rollback': {
                title: 'üîô Rollback on Error',
                content: `
                    <h3>üí° What is Rollback?</h3>
                    <pre>WITHOUT Transaction (‚ùå DANGEROUS):
repo1.save()  ‚Üí COMMIT 1 ‚úÖ
repo2.save()  ‚Üí COMMIT 2 ‚úÖ
repo3.save()  ‚Üí üí• ERROR!
Result: Database in PARTIAL state (corrupted!)

WITH Transaction (‚úÖ CORRECT):
session.begin()
repo1.save()  ‚Üí Queued
repo2.save()  ‚Üí Queued  
repo3.save()  ‚Üí üí• ERROR!
session.rollback()  ‚Üí DISCARD ALL
Result: Database UNCHANGED (consistent!)</pre>
                    <h3>üéØ Implementation</h3>
                    <pre>try:
    self.session.commit()  # Try to save all
except Exception as e:
    self.session.rollback()  # Undo everything
    raise  # Re-raise for caller</pre>
                    <h3>‚úÖ Benefits</h3>
                    <p><strong>Data integrity:</strong> Never partial state</p>
                    <p><strong>Automatic cleanup:</strong> Rollback discards all changes</p>
                    <p><strong>Safe failures:</strong> Database always consistent</p>
                `
            }
        };
        
        // Make diagram nodes clickable
        setTimeout(() => {
            const nodeMap = {
                'Service': ['Service', 'DocumentService'],
                'Service1': ['Service', 'DocumentService'],
                'Service2': ['Service', 'ProductService'],
                'Service3': ['Service', 'WarehouseService'],
                'Repos': ['Repos', '4 Repositories'],
                'Repo1': ['Repos', 'DocumentRepo'],
                'Repo2': ['Repos', 'WarehouseRepo'],
                'Repo3': ['Repos', 'ProductRepo'],
                'Repo4': ['Repos', 'InventoryRepo'],
                'TxManager': ['TxManager', 'Transaction Manager'],
                'Session': ['TxManager', 'SQLAlchemy Session']
            };
            
            Object.entries(nodeMap).forEach(([key, [detailKey, label]]) => {
                const nodes = Array.from(document.querySelectorAll('.node, .actor')).filter(node => {
                    const text = node.textContent.trim();
                    return text.includes(label);
                });
                
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    node.classList.add('clickable-node');
                    node.title = 'Click to see code details';
                    node.onclick = () => showCode(detailKey);
                });
            });
        }, 1000);
        
        function showCode(key) {
            const detail = codeDetails[key];
            if (!detail) return;
            
            document.getElementById('modalTitle').textContent = detail.title;
            document.getElementById('modalBody').innerHTML = detail.content;
            document.getElementById('codeModal').style.display = 'block';
        }
        
        function closeModal() {
            document.getElementById('codeModal').style.display = 'none';
        }
        
        window.onclick = function(event) {
            const modal = document.getElementById('codeModal');
            if (event.target == modal) {
                closeModal();
            }
        };
        
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeModal();
            }
        });
        
        // Add copy buttons to all code examples
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('.code-example');
            codeBlocks.forEach(block => {
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.textContent = 'üìã Copy';
                copyBtn.onclick = function() {
                    const code = block.textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        copyBtn.textContent = '‚úÖ Copied!';
                        setTimeout(() => {
                            copyBtn.textContent = 'üìã Copy';
                        }, 2000);
                    });
                };
                block.parentElement.insertBefore(copyBtn, block);
            });
        });
    </script>
</body>
</html>