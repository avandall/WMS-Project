<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WMS - Interactive Database Flow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #FF6F00 0%, #FF9800 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #E65100 0%, #FF9800 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.2em; opacity: 0.9; }
        .content { padding: 40px; }
        .diagram-container {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
        }
        .instructions {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 5px;
        }
        .instructions h3 { color: #F57C00; margin-bottom: 10px; }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-content {
            background: white;
            margin: 3% auto;
            padding: 0;
            width: 90%;
            max-width: 1200px;
            border-radius: 10px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            max-height: 90vh;
            overflow-y: auto;
            animation: slideDown 0.3s;
        }
        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            background: linear-gradient(135deg, #FF9800 0%, #FFB74D 100%);
            color: white;
            padding: 25px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 { font-size: 1.8em; }
        .close {
            font-size: 35px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .close:hover { transform: scale(1.2); }
        .modal-body { padding: 30px; }
        .code-section { margin-bottom: 30px; }
        .code-section h3 {
            color: #E65100;
            margin-bottom: 15px;
            font-size: 1.4em;
            padding-bottom: 10px;
            border-bottom: 2px solid #FF9800;
        }
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .code-block .comment { color: #6A9955; }
        .code-block .keyword { color: #C586C0; }
        .code-block .function { color: #DCDCAA; }
        .code-block .string { color: #CE9178; }
        .code-block .class { color: #4EC9B0; }
        .code-block .number { color: #B5CEA8; }
        .explanation {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .file-path {
            background: #263238;
            color: #80CBC4;
            padding: 8px 15px;
            border-radius: 5px 5px 0 0;
            font-family: monospace;
            font-size: 13px;
        }
        .clickable-hint {
            text-align: center;
            color: #666;
            font-style: italic;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üíæ Database & SQL Flow</h1>
            <p>PostgreSQL Operations - Click to see the actual SQL!</p>
        </div>
        
        <div class="content">
            <div class="instructions">
                <h3>üí° How to Use:</h3>
                <p><strong>Click any box</strong> to see the actual SQL queries, indexes, constraints, and performance optimizations.</p>
            </div>
            
            <div class="diagram-container">
                <div class="mermaid">
                flowchart TD
                    App([Application]):::clickable
                    Pool[Connection Pool<br/>20+10 connections]:::clickable
                    Session[Get Session]:::clickable
                    Query[Execute Query]:::clickable
                    Indexes{Use Indexes?}:::clickable
                    FastQuery[Index Scan<br/>5ms]:::clickable
                    SlowQuery[Full Table Scan<br/>500ms]:::clickable
                    Validate[Check Constraints]:::clickable
                    Execute[Execute SQL]:::clickable
                    Commit{Transaction?}:::clickable
                    CommitDB[COMMIT]:::clickable
                    RollbackDB[ROLLBACK]:::clickable
                    Result([Return Result]):::clickable
                    
                    App --> Pool
                    Pool --> Session
                    Session --> Query
                    Query --> Indexes
                    Indexes -->|Yes| FastQuery
                    Indexes -->|No| SlowQuery
                    FastQuery --> Validate
                    SlowQuery --> Validate
                    Validate --> Execute
                    Execute --> Commit
                    Commit -->|Success| CommitDB
                    Commit -->|Error| RollbackDB
                    CommitDB --> Result
                    RollbackDB --> Result
                    
                    classDef clickable fill:#FF9800,stroke:#E65100,stroke-width:3px,color:#fff,cursor:pointer
                    classDef fast fill:#4CAF50,stroke:#2E7D32,stroke-width:2px,color:#fff
                    classDef slow fill:#F44336,stroke:#B71C1C,stroke-width:2px,color:#fff
                    class FastQuery fast
                    class SlowQuery slow
                </div>
                <p class="clickable-hint">üëÜ Click any orange box to explore SQL queries</p>
            </div>
        </div>
    </div>

    <div id="codeModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">SQL Details</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" id="modalBody"></div>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });

        const codeData = {
            'Application': {
                title: 'Application Layer ‚Üí Database',
                sections: [{
                    heading: 'Repository Pattern',
                    file: 'app/repositories/sql/product_repository.py',
                    code: `<span class="keyword">class</span> <span class="class">ProductRepository</span>(<span class="class">TransactionalRepository</span>):
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, session: <span class="class">Session</span>):
        <span class="keyword">super</span>().<span class="function">__init__</span>(session)
    
    <span class="keyword">async def</span> <span class="function">get</span>(<span class="keyword">self</span>, product_id: <span class="class">int</span>) -> Optional[<span class="class">Product</span>]:
        <span class="comment"># Query database using SQLAlchemy</span>
        model = <span class="keyword">self</span>.session.<span class="function">query</span>(<span class="class">ProductModel</span>)\\
            .<span class="function">filter</span>(<span class="class">ProductModel</span>.product_id == product_id)\\
            .<span class="function">first</span>()
        
        <span class="keyword">if not</span> model:
            <span class="keyword">return None</span>
        
        <span class="comment"># Convert SQLAlchemy model to domain entity</span>
        <span class="keyword">return self</span>.<span class="function">_to_domain</span>(model)`,
                    explanation: '<strong>Repository Pattern:</strong> Repositories abstract database operations. Application code never writes SQL directly - it uses repository methods.'
                }]
            },
            'Connection Pool<br/>20+10 connections': {
                title: 'PostgreSQL Connection Pooling',
                sections: [{
                    heading: 'Connection Pool Configuration',
                    file: 'app/core/database.py',
                    code: `<span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine
<span class="keyword">from</span> sqlalchemy.pool <span class="keyword">import</span> <span class="class">QueuePool</span>

engine = <span class="function">create_engine</span>(
    settings.database_url,
    poolclass=<span class="class">QueuePool</span>,
    
    <span class="comment"># Pool configuration</span>
    pool_size=<span class="number">20</span>,           <span class="comment"># 20 persistent connections</span>
    max_overflow=<span class="number">10</span>,        <span class="comment"># + 10 temporary connections (total 30)</span>
    pool_timeout=<span class="number">30</span>,        <span class="comment"># Wait max 30s for connection</span>
    pool_recycle=<span class="number">3600</span>,      <span class="comment"># Recycle connections after 1 hour</span>
    pool_pre_ping=<span class="class">True</span>,     <span class="comment"># Test connection health before use</span>
    
    <span class="comment"># Query timeout</span>
    connect_args={
        <span class="string">"options"</span>: <span class="string">"-c statement_timeout=30000"</span>  <span class="comment"># Kill queries > 30s</span>
    }
)`,
                    explanation: '<strong>Why Connection Pooling?</strong><br>Creating new database connections is EXPENSIVE (100-500ms). Connection pool reuses existing connections, making requests 100x faster!'
                }, {
                    heading: 'How It Works',
                    file: 'PostgreSQL Connection Pool',
                    code: `<span class="comment">-- Without Pool (SLOW):</span>
Request <span class="number">1</span>: Connect (<span class="number">200ms</span>) + Query (<span class="number">5ms</span>) = <span class="number">205ms</span>
Request <span class="number">2</span>: Connect (<span class="number">200ms</span>) + Query (<span class="number">5ms</span>) = <span class="number">205ms</span>
Request <span class="number">3</span>: Connect (<span class="number">200ms</span>) + Query (<span class="number">5ms</span>) = <span class="number">205ms</span>
Total: <span class="number">615ms</span> <span class="comment">(most time wasted on connections!)</span>

<span class="comment">-- With Pool (FAST):</span>
Request <span class="number">1</span>: Get from pool (<span class="number">1ms</span>) + Query (<span class="number">5ms</span>) = <span class="number">6ms</span>
Request <span class="number">2</span>: Get from pool (<span class="number">1ms</span>) + Query (<span class="number">5ms</span>) = <span class="number">6ms</span>
Request <span class="number">3</span>: Get from pool (<span class="number">1ms</span>) + Query (<span class="number">5ms</span>) = <span class="number">6ms</span>
Total: <span class="number">18ms</span> <span class="comment">(34x faster!)</span>`,
                    explanation: '<strong>Performance Impact:</strong> Connection pooling is the #1 most important database optimization. Without it, your API cannot handle production load.'
                }]
            },
            'Get Session': {
                title: 'Database Session',
                sections: [{
                    heading: 'Session Creation',
                    file: 'app/core/database.py',
                    code: `<span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker

<span class="comment"># Session factory</span>
<span class="class">SessionLocal</span> = <span class="function">sessionmaker</span>(
    autocommit=<span class="class">False</span>,     <span class="comment"># Manual transaction control</span>
    autoflush=<span class="class">False</span>,      <span class="comment"># Manual flush control</span>
    bind=engine            <span class="comment"># Use our connection pool</span>
)

<span class="comment"># Get a session from the pool</span>
<span class="keyword">def</span> <span class="function">get_db</span>():
    db = <span class="function">SessionLocal</span>()  <span class="comment"># Gets connection from pool</span>
    <span class="keyword">try</span>:
        <span class="keyword">yield</span> db
    <span class="keyword">finally</span>:
        db.<span class="function">close</span>()        <span class="comment"># Returns connection to pool</span>`,
                    explanation: '<strong>Session Management:</strong> Each request gets its own session. The session tracks all database changes until commit() or rollback() is called.'
                }]
            },
            'Execute Query': {
                title: 'Query Execution',
                sections: [{
                    heading: 'SQLAlchemy Query',
                    file: 'app/repositories/sql/document_repository.py',
                    code: `<span class="keyword">async def</span> <span class="function">get_documents_by_status</span>(
    <span class="keyword">self</span>, 
    status: <span class="class">DocumentStatus</span>,
    page: <span class="class">int</span> = <span class="number">1</span>,
    page_size: <span class="class">int</span> = <span class="number">50</span>
) -> List[<span class="class">Document</span>]:
    <span class="comment"># SQLAlchemy query (ORM)</span>
    query = <span class="keyword">self</span>.session.<span class="function">query</span>(<span class="class">DocumentModel</span>)\\
        .<span class="function">filter</span>(<span class="class">DocumentModel</span>.status == status)\\
        .<span class="function">order_by</span>(<span class="class">DocumentModel</span>.created_at.<span class="function">desc</span>())\\
        .<span class="function">limit</span>(page_size)\\
        .<span class="function">offset</span>((page - <span class="number">1</span>) * page_size)
    
    models = query.<span class="function">all</span>()
    <span class="keyword">return</span> [<span class="keyword">self</span>.<span class="function">_to_domain</span>(m) <span class="keyword">for</span> m <span class="keyword">in</span> models]`,
                    explanation: '<strong>ORM Query:</strong> SQLAlchemy converts Python code to SQL. Easier to write, type-safe, and prevents SQL injection.'
                }, {
                    heading: 'Generated SQL (what PostgreSQL receives)',
                    file: 'PostgreSQL Query Log',
                    code: `<span class="keyword">SELECT</span> 
    documents.document_id,
    documents.doc_type,
    documents.status,
    documents.from_warehouse_id,
    documents.to_warehouse_id,
    documents.created_by,
    documents.created_at,
    documents.posted_at
<span class="keyword">FROM</span> documents
<span class="keyword">WHERE</span> documents.status = <span class="string">'DRAFT'</span>
<span class="keyword">ORDER BY</span> documents.created_at <span class="keyword">DESC</span>
<span class="keyword">LIMIT</span> <span class="number">50</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;

<span class="comment">-- Query Plan: Index Scan using ix_documents_status</span>
<span class="comment">-- Execution time: 5.2ms</span>`,
                    explanation: '<strong>SQL Translation:</strong> SQLAlchemy generates optimized SQL. Parameters are properly escaped to prevent SQL injection attacks.'
                }]
            },
            'Use Indexes?': {
                title: 'Database Indexes',
                sections: [{
                    heading: 'Index Definitions',
                    file: 'app/repositories/sql/models.py',
                    code: `<span class="keyword">class</span> <span class="class">DocumentModel</span>(<span class="class">Base</span>):
    <span class="function">__tablename__</span> = <span class="string">"documents"</span>
    
    document_id = <span class="class">Column</span>(<span class="class">Integer</span>, primary_key=<span class="class">True</span>)
    doc_type = <span class="class">Column</span>(<span class="class">String</span>, nullable=<span class="class">False</span>, index=<span class="class">True</span>)
    status = <span class="class">Column</span>(<span class="class">String</span>, nullable=<span class="class">False</span>, index=<span class="class">True</span>)
    created_at = <span class="class">Column</span>(<span class="class">DateTime</span>, nullable=<span class="class">False</span>, index=<span class="class">True</span>)
    created_by = <span class="class">Column</span>(<span class="class">String</span>, nullable=<span class="class">False</span>, index=<span class="class">True</span>)
    
    <span class="comment"># Composite indexes for common queries</span>
    <span class="function">__table_args__</span> = (
        <span class="class">Index</span>(<span class="string">'ix_documents_status_created_at'</span>, 
              <span class="string">'status'</span>, <span class="string">'created_at'</span>),
        <span class="class">Index</span>(<span class="string">'ix_documents_type_status'</span>, 
              <span class="string">'doc_type'</span>, <span class="string">'status'</span>),
        <span class="class">Index</span>(<span class="string">'ix_documents_created_by_created_at'</span>, 
              <span class="string">'created_by'</span>, <span class="string">'created_at'</span>),
    )`,
                    explanation: '<strong>8 Strategic Indexes:</strong> Indexes are like a book index - they help PostgreSQL find data 100x faster. Without indexes, database does full table scans.'
                }, {
                    heading: 'Create Index SQL',
                    file: 'Database Migration',
                    code: `<span class="comment">-- Create composite index for status + created_at queries</span>
<span class="keyword">CREATE INDEX</span> ix_documents_status_created_at 
<span class="keyword">ON</span> documents (status, created_at <span class="keyword">DESC</span>);

<span class="comment">-- Create index on product names for searches</span>
<span class="keyword">CREATE INDEX</span> ix_products_name 
<span class="keyword">ON</span> products <span class="keyword">USING</span> btree (name);

<span class="comment">-- Create unique index on warehouse locations</span>
<span class="keyword">CREATE UNIQUE INDEX</span> ix_warehouses_location 
<span class="keyword">ON</span> warehouses (location);

<span class="comment">-- Create composite index for warehouse inventory lookups</span>
<span class="keyword">CREATE INDEX</span> ix_warehouse_inventory_warehouse_product 
<span class="keyword">ON</span> warehouse_inventory (warehouse_id, product_id);`,
                    explanation: '<strong>Index Strategy:</strong> Index columns that appear in WHERE, JOIN, and ORDER BY clauses. Composite indexes support multi-column queries.'
                }]
            },
            'Index Scan<br/>5ms': {
                title: 'Fast Query with Index',
                sections: [{
                    heading: 'Query with Index',
                    file: 'PostgreSQL Execution Plan',
                    code: `<span class="keyword">EXPLAIN ANALYZE</span>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> documents 
<span class="keyword">WHERE</span> status = <span class="string">'DRAFT'</span> 
<span class="keyword">ORDER BY</span> created_at <span class="keyword">DESC</span> 
<span class="keyword">LIMIT</span> <span class="number">50</span>;

<span class="comment">-- Query Plan:</span>
Limit  (cost=<span class="number">0.42</span>..<span class="number">25.50</span> rows=<span class="number">50</span> width=<span class="number">120</span>) 
       (actual time=<span class="number">0.035</span>..<span class="number">4.821</span> ms)
  ->  <span class="class">Index Scan</span> <span class="keyword">using</span> ix_documents_status_created_at 
      <span class="keyword">on</span> documents
      Index Cond: (status = <span class="string">'DRAFT'</span>)
      Rows: <span class="number">1000</span>

<span class="comment">-- Total Execution Time: 5.2ms ‚úÖ FAST</span>
<span class="comment">-- Rows Scanned: 1000 (only matching rows)</span>`,
                    explanation: '<strong>Index Scan:</strong> PostgreSQL uses the index to jump directly to matching rows. Only reads 1,000 rows instead of 1,000,000.'
                }]
            },
            'Full Table Scan<br/>500ms': {
                title: 'Slow Query without Index',
                sections: [{
                    heading: 'Query without Index',
                    file: 'PostgreSQL Execution Plan',
                    code: `<span class="keyword">EXPLAIN ANALYZE</span>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> documents 
<span class="keyword">WHERE</span> status = <span class="string">'DRAFT'</span>   <span class="comment">-- No index on status!</span>
<span class="keyword">ORDER BY</span> created_at <span class="keyword">DESC</span>;

<span class="comment">-- Query Plan:</span>
Sort  (cost=<span class="number">25000.50</span>..<span class="number">27500.75</span> rows=<span class="number">1000</span> width=<span class="number">120</span>)
     (actual time=<span class="number">495.123</span>..<span class="number">502.456</span> ms)
  Sort Key: created_at <span class="keyword">DESC</span>
  ->  <span class="class">Seq Scan</span> <span class="keyword">on</span> documents  <span class="comment">‚ùå FULL TABLE SCAN!</span>
      Filter: (status = <span class="string">'DRAFT'</span>)
      Rows Removed by Filter: <span class="number">999000</span>
      Rows: <span class="number">1000</span>

<span class="comment">-- Total Execution Time: 512.8ms ‚ùå SLOW</span>
<span class="comment">-- Rows Scanned: 1,000,000 (entire table!)</span>`,
                    explanation: '<strong>Sequential Scan:</strong> Without an index, PostgreSQL reads EVERY row in the table. 100x slower! This is why indexes are critical.'
                }]
            },
            'Check Constraints': {
                title: 'Database Constraints',
                sections: [{
                    heading: 'Constraint Definitions',
                    file: 'app/repositories/sql/models.py',
                    code: `<span class="keyword">class</span> <span class="class">ProductModel</span>(<span class="class">Base</span>):
    <span class="function">__tablename__</span> = <span class="string">"products"</span>
    
    product_id = <span class="class">Column</span>(<span class="class">Integer</span>, primary_key=<span class="class">True</span>)
    name = <span class="class">Column</span>(<span class="class">String</span>, nullable=<span class="class">False</span>)
    price = <span class="class">Column</span>(<span class="class">Float</span>, nullable=<span class="class">False</span>)
    
    <span class="comment"># CHECK constraint: price must be positive</span>
    <span class="function">__table_args__</span> = (
        <span class="class">CheckConstraint</span>(<span class="string">'price >= 0'</span>, name=<span class="string">'check_price_positive'</span>),
    )

<span class="keyword">class</span> <span class="class">InventoryModel</span>(<span class="class">Base</span>):
    <span class="function">__tablename__</span> = <span class="string">"inventory"</span>
    
    product_id = <span class="class">Column</span>(<span class="class">Integer</span>, primary_key=<span class="class">True</span>)
    quantity = <span class="class">Column</span>(<span class="class">Integer</span>, nullable=<span class="class">False</span>)
    
    <span class="comment"># CHECK constraint: quantity cannot be negative</span>
    <span class="function">__table_args__</span> = (
        <span class="class">CheckConstraint</span>(<span class="string">'quantity >= 0'</span>, name=<span class="string">'check_quantity_positive'</span>),
    )`,
                    explanation: '<strong>Data Integrity:</strong> CHECK constraints enforce business rules at the database level. Prevents negative prices/quantities even if application code has bugs.'
                }, {
                    heading: 'Constraint Violation',
                    file: 'PostgreSQL Error',
                    code: `<span class="keyword">UPDATE</span> inventory 
<span class="keyword">SET</span> quantity = <span class="number">-10</span> 
<span class="keyword">WHERE</span> product_id = <span class="number">5</span>;

<span class="comment">-- PostgreSQL Response:</span>
<span class="class">ERROR</span>:  <span class="string">new row for relation "inventory" violates 
         check constraint "check_quantity_positive"</span>
DETAIL:  Failing row contains (product_id=<span class="number">5</span>, quantity=<span class="number">-10</span>).

<span class="comment">-- Transaction automatically rolls back ‚ùå</span>`,
                    explanation: '<strong>Safety Net:</strong> Even if your application tries to save invalid data, the database rejects it. This prevents data corruption.'
                }]
            },
            'Execute SQL': {
                title: 'SQL Execution',
                sections: [{
                    heading: 'INSERT Statement',
                    file: 'PostgreSQL Query',
                    code: `<span class="comment">-- Create new product</span>
<span class="keyword">INSERT INTO</span> products (name, description, price)
<span class="keyword">VALUES</span> (
    <span class="string">'Laptop Dell XPS 15'</span>,
    <span class="string">'High-performance laptop'</span>,
    <span class="number">1500.00</span>
)
<span class="keyword">RETURNING</span> product_id;

<span class="comment">-- Result: product_id = 123</span>`,
                    explanation: '<strong>INSERT:</strong> Creates new row. RETURNING clause gets the auto-generated ID without a second query.'
                }, {
                    heading: 'UPDATE Statement',
                    file: 'PostgreSQL Query',
                    code: `<span class="comment">-- Update document status</span>
<span class="keyword">UPDATE</span> documents
<span class="keyword">SET</span> 
    status = <span class="string">'POSTED'</span>,
    posted_at = <span class="keyword">NOW</span>(),
    posted_by = <span class="string">'admin'</span>
<span class="keyword">WHERE</span> document_id = <span class="number">1</span>;

<span class="comment">-- Rows affected: 1</span>`,
                    explanation: '<strong>UPDATE:</strong> Modifies existing rows. WHERE clause prevents accidental updates to all rows.'
                }, {
                    heading: 'DELETE Statement',
                    file: 'PostgreSQL Query',
                    code: `<span class="comment">-- Delete warehouse inventory record</span>
<span class="keyword">DELETE FROM</span> warehouse_inventory
<span class="keyword">WHERE</span> warehouse_id = <span class="number">1</span> 
  <span class="keyword">AND</span> product_id = <span class="number">5</span>
  <span class="keyword">AND</span> quantity = <span class="number">0</span>;  <span class="comment">-- Only delete if empty</span>

<span class="comment">-- Rows affected: 1</span>`,
                    explanation: '<strong>DELETE:</strong> Removes rows. Always use WHERE clause to avoid deleting everything!'
                }]
            },
            'Transaction?': {
                title: 'Transaction Decision',
                sections: [{
                    heading: 'Transaction Block',
                    file: 'PostgreSQL Transaction',
                    code: `<span class="comment">-- Start transaction</span>
<span class="keyword">BEGIN</span>;

<span class="comment">-- Multiple operations in one transaction</span>
<span class="keyword">UPDATE</span> warehouse_inventory 
<span class="keyword">SET</span> quantity = quantity + <span class="number">100</span> 
<span class="keyword">WHERE</span> warehouse_id = <span class="number">1</span> <span class="keyword">AND</span> product_id = <span class="number">5</span>;

<span class="keyword">UPDATE</span> inventory 
<span class="keyword">SET</span> quantity = quantity + <span class="number">100</span> 
<span class="keyword">WHERE</span> product_id = <span class="number">5</span>;

<span class="keyword">UPDATE</span> documents 
<span class="keyword">SET</span> status = <span class="string">'POSTED'</span> 
<span class="keyword">WHERE</span> document_id = <span class="number">1</span>;

<span class="comment">-- Decide: COMMIT or ROLLBACK</span>
<span class="comment">-- If any error occurred ‚Üí ROLLBACK</span>
<span class="comment">-- If all successful ‚Üí COMMIT</span>`,
                    explanation: '<strong>ACID Transaction:</strong> BEGIN starts a transaction. All changes are isolated until COMMIT or ROLLBACK.'
                }]
            },
            'COMMIT': {
                title: 'Transaction Commit',
                sections: [{
                    heading: 'COMMIT Operation',
                    file: 'PostgreSQL Transaction',
                    code: `<span class="keyword">BEGIN</span>;

<span class="keyword">UPDATE</span> warehouse_inventory <span class="keyword">SET</span> quantity = quantity + <span class="number">100</span>...;
<span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> quantity = quantity + <span class="number">100</span>...;
<span class="keyword">UPDATE</span> documents <span class="keyword">SET</span> status = <span class="string">'POSTED'</span>...;

<span class="comment">-- All operations successful ‚úÖ</span>
<span class="keyword">COMMIT</span>;

<span class="comment">-- Changes are now PERMANENT and VISIBLE to other users</span>`,
                    explanation: '<strong>COMMIT:</strong> Makes all changes permanent. After COMMIT, data is written to disk and visible to all database users. Cannot be undone!'
                }, {
                    heading: 'What Happens on COMMIT',
                    file: 'PostgreSQL Internals',
                    code: `<span class="comment">-- COMMIT process:</span>
<span class="number">1.</span> Write changes to Write-Ahead Log (WAL)
<span class="number">2.</span> Flush WAL to disk (ensures durability)
<span class="number">3.</span> Mark transaction as committed
<span class="number">4.</span> Make changes visible to other sessions
<span class="number">5.</span> Release locks
<span class="number">6.</span> Update transaction log

<span class="comment">-- If power fails AFTER step 2, changes are recovered ‚úÖ</span>
<span class="comment">-- If power fails BEFORE step 2, changes are lost ‚ùå</span>`,
                    explanation: '<strong>Durability:</strong> COMMIT guarantees data is written to disk. Even if server crashes immediately after COMMIT, data is safe.'
                }]
            },
            'ROLLBACK': {
                title: 'Transaction Rollback',
                sections: [{
                    heading: 'ROLLBACK Operation',
                    file: 'PostgreSQL Transaction',
                    code: `<span class="keyword">BEGIN</span>;

<span class="keyword">UPDATE</span> warehouse_inventory <span class="keyword">SET</span> quantity = quantity + <span class="number">100</span>...;
<span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> quantity = quantity + <span class="number">100</span>...;

<span class="comment">-- ERROR: Constraint violation!</span>
<span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> quantity = <span class="number">-10</span> <span class="keyword">WHERE</span>...;
<span class="comment">-- ERROR: check constraint "check_quantity_positive" violated</span>

<span class="keyword">ROLLBACK</span>;  <span class="comment">-- Undo ALL changes ‚ùå</span>

<span class="comment">-- Result: Database is UNCHANGED, as if transaction never happened</span>`,
                    explanation: '<strong>ROLLBACK:</strong> Discards ALL changes in the transaction. Database returns to state before BEGIN. Prevents partial/corrupted data.'
                }, {
                    heading: 'Automatic Rollback',
                    file: 'app/services/document_service.py',
                    code: `<span class="keyword">try</span>:
    <span class="comment"># Multiple database operations</span>
    <span class="keyword">self</span>.warehouse_repo.<span class="function">add_product</span>(...)
    <span class="keyword">self</span>.inventory_repo.<span class="function">add_quantity</span>(...)
    <span class="keyword">self</span>.document_repo.<span class="function">update</span>(...)
    
    <span class="comment"># If we reach here, all operations succeeded</span>
    session.<span class="function">commit</span>()
    
<span class="keyword">except</span> <span class="class">Exception</span> <span class="keyword">as</span> e:
    <span class="comment"># ANY error triggers automatic rollback</span>
    session.<span class="function">rollback</span>()
    logger.<span class="function">error</span>(<span class="string">f"Transaction failed: {e}"</span>)
    <span class="keyword">raise</span>`,
                    explanation: '<strong>Error Handling:</strong> Python code catches any exception and calls rollback(). This prevents half-completed operations from corrupting data.'
                }]
            },
            'Return Result': {
                title: 'Query Result',
                sections: [{
                    heading: 'Return Data to Application',
                    file: 'SQLAlchemy ORM',
                    code: `<span class="comment"># Query result (list of ORM models)</span>
models = session.<span class="function">query</span>(<span class="class">DocumentModel</span>)\\
    .<span class="function">filter</span>(status=<span class="string">'DRAFT'</span>)\\
    .<span class="function">all</span>()

<span class="comment"># Convert to domain entities</span>
documents = [<span class="function">to_domain</span>(model) <span class="keyword">for</span> model <span class="keyword">in</span> models]

<span class="comment"># Return to service layer</span>
<span class="keyword">return</span> documents`,
                    explanation: '<strong>Result Mapping:</strong> SQLAlchemy converts PostgreSQL rows to Python objects. Repository converts ORM models to domain entities.'
                }]
            }
        };

        // Modal handling
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('codeModal');
            const span = document.getElementsByClassName('close')[0];
            
            span.onclick = () => modal.style.display = 'none';
            window.onclick = (event) => {
                if (event.target == modal) modal.style.display = 'none';
            };
            
            setTimeout(() => {
                document.querySelectorAll('.node').forEach(node => {
                    node.style.cursor = 'pointer';
                    node.addEventListener('click', function() {
                        const text = this.querySelector('span').textContent.trim();
                        showCode(text);
                    });
                });
            }, 1000);
        });

        function showCode(nodeText) {
            const data = codeData[nodeText];
            if (!data) return;
            
            document.getElementById('modalTitle').textContent = data.title;
            
            let html = '';
            data.sections.forEach(section => {
                html += `
                    <div class="code-section">
                        <h3>${section.heading}</h3>
                        <div class="file-path">üìÅ ${section.file}</div>
                        <div class="code-block">${section.code}</div>
                        <div class="explanation">${section.explanation}</div>
                    </div>
                `;
            });
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('codeModal').style.display = 'block';
        }
    </script>
</body>
</html>